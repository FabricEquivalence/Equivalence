plugins {
	id 'fabric-loom' version '0.10-SNAPSHOT'
	id 'maven-publish'
}

sourceCompatibility = JavaVersion.VERSION_17
targetCompatibility = JavaVersion.VERSION_17

archivesBaseName = project.archives_base_name
version = project.mod_version
group = project.maven_group

repositories {
	// Add repositories to retrieve artifacts from in here.
	// You should only use this when depending on other mods because
	// Loom adds the essential maven repositories to download Minecraft and libraries from automatically.
	// See https://docs.gradle.org/current/userguide/declaring_repositories.html
	// for more information about repositories.
}

dependencies {
	// To change the versions see the gradle.properties file
	minecraft "com.mojang:minecraft:${project.minecraft_version}"
	mappings "net.fabricmc:yarn:${project.yarn_mappings}:v2"
	modImplementation "net.fabricmc:fabric-loader:${project.loader_version}"

	// Fabric API. This is technically optional, but you probably want it anyway.
	modImplementation "net.fabricmc.fabric-api:fabric-api:${project.fabric_version}"

	// PSA: Some older mods, compiled on Loom 0.2.1, might have outdated Maven POMs.
	// You may need to force-disable transitiveness on them.
}

processResources {
	inputs.property "version", project.version

	filesMatching("fabric.mod.json") {
		expand "version": project.version
	}
}

tasks.withType(JavaCompile).configureEach {
	// ensure that the encoding is set to UTF-8, no matter what the system default is
	// this fixes some edge cases with special characters not displaying correctly
	// see http://yodaconditions.net/blog/fix-for-java-file-encoding-problems-with-gradle.html
	// If Javadoc is generated, this must be specified in that task too.
	it.options.encoding = "UTF-8"

	// Minecraft 1.18 upwards uses Java 17.
	it.options.release = 17
}

java {
	// Loom will automatically attach sourcesJar to a RemapSourcesJar task and to the "build" task
	// if it is present.
	// If you remove this line, sources will not be generated.
	withSourcesJar()
}

jar {
	from("LICENSE") {
		rename { "${it}_${project.archivesBaseName}"}
	}
}

// configure the maven publication
publishing {
	publications {
		mavenJava(MavenPublication) {
			// add all the jars that should be included when publishing to maven
			artifact(remapJar) {
				builtBy remapJar
			}
			artifact(sourcesJar) {
				builtBy remapSourcesJar
			}
		}
	}

	// See https://docs.gradle.org/current/userguide/publishing_maven.html for information on how to set up publishing.
	repositories {
		// Add repositories to publish to here.
		// Notice: This block does NOT have the same function as the block in the top level.
		// The repositories here will be used for publishing your artifact, not for
		// retrieving dependencies.
	}
}

task compileRecipes(type: CompileRecipesTask)

project.build.dependsOn compileRecipes

class CompileRecipesTask extends DefaultTask {
	@TaskAction
	def compile() {
		def slurper = new groovy.json.JsonSlurper()
		ArrayList recipeTrees = slurper.parse(project.file('src/main/resources/recipe_trees.json'))
		for (def parsedTree: recipeTrees) {
			def tree = new RecipeTree(parsedTree.name, parsedTree.items)
			tree.announce()
			tree.writeRecipes();
		}
	}

	class RecipeTree {
		String name;
		ArrayList<String> items;
		ArrayList<Recipe> recipes = new ArrayList<Recipe>();

		RecipeTree(String name, ArrayList<String> items) {
			this.name = name;
			this.items = items;

			this.buildRecipes();
		}

		void buildRecipes() {
			for (int i = 0; i < this.items.size() - 1; i++) {
				recipes.add(
						this.buildRecipe(items.get(i), items.get(i + 1))
				)
				recipes.add(
						this.buildRecipe(items.get(i + 1), items.get(i))
				)
			}
		}

		Recipe buildRecipe(String from, String to) {
			EMCProvider emcProvider = new EMCProvider();
			int fromEmc = emcProvider.value(from);
			int toEmc = emcProvider.value(to);
			ItemStack fromStack, toStack;
			if (fromEmc > toEmc) {
				fromStack = new ItemStack(from, 1);
				toStack = new ItemStack(to, (fromEmc / toEmc) as int);
			} else {
				fromStack = new ItemStack(from, (toEmc / fromEmc) as int);
				toStack = new ItemStack(to, 1);
			}
			return new Recipe(fromStack, toStack);
		}

		void announce() {
			println String.format("Found tree: %s", this.name)
			for (int i = 0; i < this.items.size(); i++) {
				println String.format("\tFound item: %s", this.items.get(i))
			}

			for (Recipe recipe: this.recipes) {
				println String.format("\tGenerated recipe %s: %s", recipe.getName(), recipe.toString());
				println String.format("\tRecipe JSON: \n====\n%s\n====", recipe.toJson());
			}
		}

		void writeRecipes() {
			for (Recipe recipe: this.recipes) {
				recipe.write();
			}
		}
	}

	class EMCProvider {
		AbstractMap<String, Integer> values;

		EMCProvider() {
			def slurper = new groovy.json.JsonSlurper()
			this.values = slurper.parse(project.file('src/main/resources/emc_values.json'))
		}

		int value(String item) {
			if (this.values.containsKey(item)) {
				return this.values.get(item)
			} else {
				return 1;
			}
		}

		int value(ItemStack stack) {
			return this.values.get(stack.item) * stack.quantity
		}
	}

	class Recipe {
		ArrayList<ItemStack> ingredients;
		ArrayList<ItemStack> results;

		Recipe (ArrayList<ItemStack> ingredients, ArrayList<ItemStack> results) {
			this.ingredients = ingredients;
			this.results = results;
		}

		Recipe (ItemStack ingredient, ItemStack result) {
			this.ingredients = new ArrayList<ItemStack>();
			this.results = new ArrayList<ItemStack>();
			this.ingredients.add(ingredient);
			this.results.add(result);
		}

		void write() {
			File recipeFile = new File(
					project.getProjectDir(),
					"src/main/resources/data/equivalence/recipes/generated_from_trees/"
							.concat(this.getName())
							.concat(".json")
			);
			if (!recipeFile.exists()) {
				recipeFile.createNewFile()
			};
			recipeFile.text = this.toJson();
		}

		String toString() {
			String from = "From ( ";
			for (ItemStack stack: ingredients) {
				from = from.concat(String.format("%d %s, ", stack.quantity, stack.item))
			}
			from = from.substring(0, from.length() - 2);
			from = from.concat(" )");

			String to = "To ( ";
			for (ItemStack stack: results) {
				to = to.concat(String.format("%d %s, ", stack.quantity, stack.item))
			}
			to = to.substring(0, to.length() - 2);
			to = to.concat(" )");

			return from.concat(" ").concat(to);
		}

		String getName() {
			String from = "convert_";
			for (ItemStack stack: ingredients) {
				from = from.concat(String.format("%s_", stack.getSimpleItemName()))
			}

			String to = "to_";
			for (ItemStack stack: results) {
				to = to.concat(String.format("%s_", stack.getSimpleItemName()))
			}
			to = to.substring(0, to.length() - 1);

			return from.concat(to);
		}

		String toJson() {
			String json = new String();
			json = json.concat("{\n  \"type\": \"equivalence:shapeless_custom_remainder\",\n");
			json = json.concat("  \"ingredients\": [\n");
			// always add philosopher's stone as first ingredient
			json = json.concat("    {\n");
			json = json.concat("      \"item\": \"equivalence:philosophers_stone\"\n");
			json = json.concat("    },\n");
			for (ItemStack ingredient: this.ingredients) {
				for (int i=0; i< ingredient.quantity; i++) {
					json = json.concat("    {\n");
					json = json.concat("      \"item\": \"").concat(ingredient.item).concat("\"\n");
					json = json.concat("    },\n");
				}
			}
			json = json.substring(0, json.length() - 2); // remove trailing comma to generate valid JSON
			json = json.concat("\n");
			json = json.concat("  ],\n");
			json = json.concat("  \"result\": {\n");
			json = json.concat("    \"item\": \"").concat(this.results.get(0).item).concat("\",\n");
			json = json.concat("    \"count\": ").concat((String) this.results.get(0).quantity).concat("\n");
			json = json.concat("  }\n");
			json = json.concat("}");

			return json;
		}
	}

	class ItemStack {
		String item;
		int quantity;

		ItemStack (String item, int quantity = 1) {
			this.item = item;
			this.quantity = quantity;
		}

		String getSimpleItemName() {
			String[] nameSegments = this.item.split(':');
			if (nameSegments.length == 1) {
				return nameSegments[0];
			} else {
				return nameSegments[1];
			}
		}
	}
}